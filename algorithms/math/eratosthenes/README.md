## Классическое решето Эратосфена

Этот алгоритм строит массив $prime$ размера $N$, в котором $prime_i$ равно $true$, если число $i$ простое, и $false$ в противном случае. Асимптотика алгоритма — $O(n\log{\log{n}})$

### Описание алгоритма:
    
1. Изначально массив $prime$ заполняется значениями $true$, кроме $prime_0$ и $prime_1$, которые устанавливаются в $false$, поскольку 0 и 1 не являются простыми.
2. Затем для каждого числа $i$ В диапазоне от 2 до $\sqrt{N}$, если $prime_i$ равно $true$ (т.е. $i$ простое) то все кратные $i$ числа, начиная с $i^2$, помечаются как составные.

## Решето Эратосфена с линейным временем работы
Этот алгоритм не только позволяет проверять числа на простоту, но и быстро факторизовать числа. Он строит массив $sieve$, в котором $sieve_i$ хранит минимальный простой делитель числа $i$.

### Описание алгоритма:

1. Инициализируем массив $sieve$ нулями (что означает, что число еще не рассмотрено) и массив $pr$ для хранения простых чисел.
2. Для каждого числа $i$ от 2 до $N$. У нас может быть два случая:
   - $sieve_i = 0$ — это означает, что число i — простое. Присваиваем $sieve_i = i$ и добавляем $i$ в массив $pr$.
   - $sieve_i \ne 0$ — это означает, что число i — составное, и его минимальным простым делителем является $sieve_i$.

   Далее, в любом из этих случаев, мы расставляем значения в массиве $sieve$ в индексах, кратных $i$. Для этого рассмотрим последовательность $p_j$ всех простых чисел, не превосходящих $sieve_i$ и софрмируем последовательность $x_j = i \cdot p_j$. В такой последовательности, очевидно, значение $sieve_{x_j} = p_j$.

Поскольку по определению, $sieve_i$ является наименьшим делителем числа $i$ то, очевидно, $sieve_i \le sieve_x$, где $x = \frac{i}{sieve_i}$.

Теперь сравним это с тем, что делает наш алгоритм — он фактически для каждого $x$ перебирает все простые, на которые его можно домножить, т.е. простые до $sieve_x$ включительно, чтобы получить числа в указанном выше представлении.

Следовательно, алгоритм действительно пройдёт по каждому составному числу ровно один раз, поставив у него правильное значение в $sieve$.

Это означает корректность алгоритма и то, что он работает за линейное время.